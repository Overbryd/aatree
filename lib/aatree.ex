# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2017-05-28 14:05:15
defmodule Aatree do
  @typep aatree_node() :: nil | {any(), any(), any(), any()}
  @opaque iter() :: list(aatree_node())
  @opaque aatree() :: {non_neg_integer(), aatree_node()}

  use Bitwise, only_operators: true

  defmacrop erlconst_p() do
    quote do
      2
    end
  end


  defmacrop erlmacro_pow(a, _) do
    quote do
      unquote(a) * unquote(a)
    end
  end


  defmacrop erlmacro_div2(x) do
    quote do
      unquote(x) >>> 1
    end
  end


  defmacrop erlmacro_mul2(x) do
    quote do
      unquote(x) <<< 1
    end
  end


  @type t :: %__MODULE__{
    tree: aatree,
    comparator: fun
  }

  defstruct [tree: {0, nil}, comparator: &__MODULE__.compare_terms/2]


  @spec new(fun) :: t

  def new(comparator: comparator) do
    %Aatree{comparator: comparator}
  end

  @spec new() :: t

  def new, do: %Aatree{}

  @spec compare_terms(term, term) :: 0 | -1 | 1

  def compare_terms(%{__struct__: type1} = term1, %{__struct__: type2} = term2) when type1 === type2 do
    if function_exported?(type1, :compare, 2) do
      type1.compare(term1, term2)
    else
      do_compare_terms(term1, term2)
    end
  end

  def compare_terms(term1, term2), do: do_compare_terms(term1, term2)

  defp do_compare_terms(term1, term2) do
    cond do
      term1 === term2 -> 0
      term1 < term2 -> -1
      term1 > term2 -> 1
      term1 == term2 ->
        case do_compare_terms(hash_term(term1), hash_term(term2)) do
          0 -> do_compare_terms(fallback_term_hash(term1), fallback_term_hash(term2))
          hash_comparison_result -> hash_comparison_result
        end
    end
  end

  @key_hash_bucket 4294967296

  # Â¡This is only used as a tiebreaker!
  # For cases when `insert_key !== node_key` but `insert_key == node_key` (e.g.
  # `1` and `1.0`,) hash the keys to provide consistent ordering.
  defp hash_term(term) do
    :erlang.phash2(term, @key_hash_bucket)
  end

  # In the case that `hash_term(term1) == hash_term(term2)` we can fall back
  # again to the slower phash function distributed over @key_hash_bucket
  # integers.
  # If these two collide, go home.
  defp fallback_term_hash(term) do
    :erlang.phash(term, @key_hash_bucket)
  end

  @spec empty() :: aatree()

  def empty() do
    {0, nil}
  end


  @spec empty?(t) :: boolean()

  def empty?(%Aatree{tree: {0, nil}}), do: true

  defp is_empty({0, nil}) do
    true
  end

  defp is_empty(_) do
    false
  end


  @spec count(t) :: non_neg_integer() when t: t()

  def count(%Aatree{tree: {var_size, _}}) when is_integer(var_size) and var_size >= 0 do
    var_size
  end

  @spec member?(t, key) :: boolean() when key: term()

  def member?(%Aatree{tree: {_, t}, comparator: cmp}, key) do
    is_defined_t(key, cmp, t)
  end

  defp is_defined_t(key, _cmp, nil), do: false

  defp is_defined_t(key, cmp, {key1, _, smaller, bigger} = t) do
    case cmp.(key, key1) do
      -1 -> is_defined_t(key, cmp, smaller)
      1 -> is_defined_t(key, cmp, bigger)
      _ -> key === key1
    end
  end

  @spec get(t, key) :: nil | val when key: term(), val: term()

  def get(%Aatree{} = aatree, key) do
    get(aatree, key, nil)
  end

  @spec get(t, key, default) :: default | val when key: term(), val: term(), default: term()

  def get(%Aatree{tree: {_, t}, comparator: cmp} = aatree, key, default) do
    if member?(aatree, key) do
      get_1(key, cmp, t)
    else
      default
    end
  end

  defp get_1(key, cmp, {key1, value, smaller, bigger}) do #when key < key1 do
    case cmp.(key, key1) do
      -1 -> get_1(key, cmp, smaller)
      1 -> get_1(key, cmp, bigger)
      0 -> value
    end
  end

  @spec put(t1, key, val) :: t2 when key: term(), val: term(), t1: t(), t2: t()

  def put(%Aatree{tree: tree, comparator: cmp} = aatree, key, val) do
    if member?(aatree, key) do
      %Aatree{aatree | tree: update(key, val, cmp, tree)}
    else
      %Aatree{aatree | tree: insert(key, val, cmp, tree)}
    end
  end

  @spec update(key, val, fun, tree1) :: tree2 when key: term(), val: term(), tree1: aatree(), tree2: aatree()

  defp update(key, val, cmp, {s, t}) do
    t1 = update_1(key, val, cmp, t)
    {s, t1}
  end

  defp update_1(key, value, cmp, {key1, v, smaller, bigger}) do
    case cmp.(key, key1) do
      -1 -> {key1, v, update_1(key, value, cmp, smaller), bigger}
      1 -> {key1, v, smaller, update_1(key, value, cmp, bigger)}
      0 -> {key, value, smaller, bigger}
    end
  end


  @spec insert(key, val, fun, tree1) :: tree2 when key: term(), val: term(), tree1: aatree(), tree2: aatree()

  defp insert(key, val, cmp, {s, t}) when is_integer(s) do
    s1 = s + 1
    {s1, insert_1(key, val, cmp, t, erlmacro_pow(s1, erlconst_p()))}
  end

  defp insert_1(key, value, cmp, {key1, v, smaller, bigger} = t, s) do #when key < key1 do
    case cmp.(key, key1) do
      -1 ->
        case(insert_1(key, value, cmp, smaller, erlmacro_div2(s))) do
          {t1, h1, s1} ->
            t = {key1, v, t1, bigger}
            {h2, s2} = count_t(bigger)
            h = erlmacro_mul2(:erlang.max(h1, h2))
            sS = s1 + s2 + 1
            p = erlmacro_pow(sS, erlconst_p())
            case(:if) do
              :if when h > p ->
                balance(t, sS)
              :if when true ->
                {t, h, sS}
            end
          t1 ->
            {key1, v, t1, bigger}
        end
      1 ->
        case(insert_1(key, value, cmp, bigger, erlmacro_div2(s))) do
          {t1, h1, s1} ->
            t = {key1, v, smaller, t1}
            {h2, s2} = count_t(smaller)
            h = erlmacro_mul2(:erlang.max(h1, h2))
            sS = s1 + s2 + 1
            p = erlmacro_pow(sS, erlconst_p())
            case(:if) do
              :if when h > p ->
                balance(t, sS)
              :if when true ->
                {t, h, sS}
            end
          t1 ->
            {key1, v, smaller, t1}
        end
      0 -> insert_1(key, value, cmp, t, s)
    end
  end

  defp insert_1(key, value, cmp, nil, s) when s === 0 do
    {{key, value, nil, nil}, 1, 1}
  end

  defp insert_1(key, value, cmp, nil, _s) do
    {key, value, nil, nil}
  end

  defp insert_1(key, _, cmp, _, _) do
    :erlang.error({:key_exists, key})
  end

  defp count_t({_, _, nil, nil}) do
    {1, 1}
  end

  defp count_t({_, _, sm, bi}) do
    {h1, s1} = count_t(sm)
    {h2, s2} = count_t(bi)
    {erlmacro_mul2(:erlang.max(h1, h2)), s1 + s2 + 1}
  end

  defp count_t(nil) do
    {1, 0}
  end


  @spec balance(tree1) :: tree2 when tree1: aatree(), tree2: aatree()


  def balance({s, t}) do
    {s, balance(t, s)}
  end


  def balance(t, s) do
    balance_list(to_list_t(t), s)
  end


  def balance_list(l, s) do
    {t, []} = balance_list_1(l, s)
    t
  end


  defp balance_list_1(l, s) when s > 1 do
    sm = s - 1
    s2 = div(sm, 2)
    s1 = sm - s2
    {t1, [{k, v} | l1]} = balance_list_1(l, s1)
    {t2, l2} = balance_list_1(l1, s2)
    t = {k, v, t1, t2}
    {t, l2}
  end

  defp balance_list_1([{key, val} | l], 1) do
    {{key, val, nil, nil}, l}
  end

  defp balance_list_1(l, 0) do
    {nil, l}
  end


  @spec from_orddict(list) :: tree when list: list({term(), term()}), tree: aatree()


  def from_orddict(l) do
    s = length(l)
    {s, balance_list(l, s)}
  end


  @spec delete(tree1, key) :: tree2 when key: term(), tree1: aatree(), tree2: aatree()

  def delete(%Aatree{tree: {s, t}, comparator: cmp} = aatree, key) when is_integer(s) and s >= 0 do
    if member?(aatree, key) do
      new_tree = {s - 1, delete_1(key, cmp, t)}
      %Aatree{aatree | tree: new_tree}
    else
      aatree
    end
  end


  defp delete_1(key, cmp, {key1, value, smaller, bigger}) do #when key < key1 do
    case cmp.(key, key1) do
      -1 -> 
        smaller1 = delete_1(key, cmp, smaller)
        {key1, value, smaller1, bigger}
      1 ->
        bigger1 = delete_1(key, cmp, bigger)
        {key1, value, smaller, bigger1}
      0 ->
        merge_t(smaller, bigger)
    end
  end

  defp delete_1(_, {_, _, smaller, larger}) do
    merge(smaller, larger)
  end


  defp merge_t(smaller, nil) do
    smaller
  end

  defp merge_t(nil, larger) do
    larger
  end

  defp merge_t(smaller, larger) do
    {key, value, larger1} = take_smallest_1(larger)
    {key, value, smaller, larger1}
  end


  @spec take_smallest(tree1) :: {key, val, tree2} when tree1: aatree(), tree2: aatree(), key: term(), val: term()

  def take_smallest({var_size, tree}) when is_integer(var_size) and var_size >= 0 do
    {key, value, larger} = take_smallest_1(tree)
    {key, value, {var_size - 1, larger}}
  end


  defp take_smallest_1({key, value, nil, larger}) do
    {key, value, larger}
  end

  defp take_smallest_1({key, value, smaller, larger}) do
    {key1, value1, smaller1} = take_smallest_1(smaller)
    {key1, value1, {key, value, smaller1, larger}}
  end


  @spec smallest(t) :: nil | {key, val} when key: term(), val: term()

  def smallest(%Aatree{tree: {_, t} = tree}) do
    if is_empty(tree) do
      nil
    else
      smallest_t(t)
    end
  end


  defp smallest_t({key, value, nil, _larger}) do
    {key, value}
  end

  defp smallest_t({_key, _value, smaller, _larger}) do
    smallest_t(smaller)
  end


  @spec take_largest(tree1) :: {key, val, tree2} when tree1: aatree(), tree2: aatree(), key: term(), val: term()


  def take_largest({var_size, tree}) when is_integer(var_size) and var_size >= 0 do
    {key, value, smaller} = take_largest1(tree)
    {key, value, {var_size - 1, smaller}}
  end


  defp take_largest1({key, value, smaller, nil}) do
    {key, value, smaller}
  end

  defp take_largest1({key, value, smaller, larger}) do
    {key1, value1, larger1} = take_largest1(larger)
    {key1, value1, {key, value, smaller, larger1}}
  end


  @spec largest(t) :: nil | {key, val} when key: term(), val: term()


  def largest(%Aatree{tree: {_, t} = tree}) do
    if is_empty(tree) do
      nil
    else
      largest_t(t)
    end
  end

  defp largest_t({key, value, _smaller, nil}) do
    {key, value}
  end

  defp largest_t({_key, _value, _smaller, larger}) do
    largest_t(larger)
  end


  @spec to_list(t) :: list({key, val}) when key: term(), val: term()


  def to_list(%Aatree{tree: {_, t}}) do
    to_list_t(t, [])
  end


  defp to_list_t(t) do
    to_list_t(t, [])
  end


  defp to_list_t({key, value, small, big}, l) do
    to_list_t(small, [{key, value} | to_list_t(big, l)])
  end

  defp to_list_t(nil, l) do
    l
  end


  @spec keys(t) :: list(key) when key: term()

  def keys(%Aatree{tree: {_, t}}) do
    keys_t(t, [])
  end

  defp keys_t({key, _value, small, big}, l) do
    keys_t(small, [key | keys_t(big, l)])
  end

  defp keys_t(nil, l) do
    l
  end


  @spec values(t) :: list(val) when val: term()

  def values(%Aatree{tree: {_, t}}) do
    values_t(t, [])
  end

  defp values_t({_key, value, small, big}, l) do
    values_t(small, [value | values_t(big, l)])
  end

  defp values_t(nil, l) do
    l
  end


  @spec iterator(tree) :: iter when tree: aatree(), iter: iter()

  def iterator({_, t}) do
    iterator_1(t)
  end


  def iterator_1(t) do
    iterator(t, [])
  end


  def iterator({_, _, nil, _} = t, as) do
    [t | as]
  end

  def iterator({_, _, l, _} = t, as) do
    iterator(l, [t | as])
  end

  def iterator(nil, as) do
    as
  end


  @spec next(iter1) :: :none | {key, val, iter2} when iter1: iter(), iter2: iter(), key: term(), val: term()


  def next([{x, v, _, t} | as]) do
    {x, v, iterator(t, as)}
  end

  def next([]) do
    :none
  end


  @spec map(function, tree1) :: tree2 when function: (term(), term() -> term()), tree1: aatree(), tree2: aatree()


  def map(f, {var_size, tree}) when is_function(f, 2) do
    {var_size, map_1(f, tree)}
  end


  defp map_1(_, nil) do
    nil
  end

  defp map_1(f, {k, v, smaller, larger}) do
    {k, f.(k, v), map_1(f, smaller), map_1(f, larger)}
  end

  @spec to_string(tree) :: String.t when tree: aatree()

  def to_string({size, tree}) do
    "\n(size:" <> Integer.to_string(size) <> ")\n" <> do_to_string "", tree
  end
  def do_to_string(_, nil) do
    "\n"
  end
  def do_to_string(pref, {k, v, smaller, larger}) do
       "{ " <> Kernel.inspect(k) <> ", " <> Kernel.inspect(v) <> " }"
       <> ")\n"
    <> pref <> "+ " <> do_to_string(("  " <> pref), smaller)
    <> pref <> "+ " <> do_to_string(("  " <> pref), larger)
  end


  # def nth({_,0}, _n) do
  #   nil
  # end
  # def nth({_,size}, n) when n > size - 1 do
  #   nil
  # end
  # def nth({r,size}, n) when n < 0 do
  #   do_nth(r, size + n)
  # end
  # def nth({r,_}, n) when n >= 0 do
  #   do_nth(r, n)
  # end

  # defp do_nth({_,h,k,v,l,r}, n) do
  #   l_count = left_count(h)
  #   cond do
  #     l_count > n && l == nil -> {k,v}
  #     l_count > n -> do_nth(l, n)
  #     l_count == n -> {k,v}
  #     r == nil -> {k,v}
  #     true -> do_nth(r, n - l_count - 1)
  #   end
  # end

end
